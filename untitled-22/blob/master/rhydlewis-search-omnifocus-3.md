# rhydlewis/search-omnifocus

 from \_\_future\_\_ import unicode\_literals import os from datetime import datetime from omnifocus import DEFAULT\_OF2\_PERSPECTIVES, DEFAULT\_OF3\_PERSPECTIVES from workflow import ICON\_WARNING from queries import ALLOWS\_NEXT\_ACTION, AVAILABLE\_TASK\_COUNT, BLOCKED, BLOCKED\_BY\_START\_DATE, CHILD\_COUNT, \ DUE\_DATE, EFFECTIVE\_IN\_INBOX, EFFECTIVE\_START\_DATE, FOLDER\_NAME, ID, IN\_INBOX, NAME, PROJECT\_NAME, START\_DATE, \ STATUS, CONTAINING\_PROJECT\_INFO, MODIFIED\_DATE STATUS\_ACTIVE = 'active' STATUS\_DONE = 'done' STATUS\_DROPPED = 'dropped' STATUS\_INACTIVE = 'inactive' DATETIME\_FORMAT = '%Y-%m-%dT%H:%M:%S.%fZ' DATETIME\_OFFSET = 978307200 FOLDER\_PREFIX = 'en.lproj/OmniFocus Help/art/' class Item\(object\): def \_\_init\_\_\(self, item\_type, persistent\_id, name, subtitle, icon\): self.item\_type = item\_type self.name = name self.persistent\_id = persistent\_id self.subtitle = subtitle self.icon = icon def \_\_repr\_\_\(self\): return "{0}: {1}, \({2}\), {3}, {4}".format\(self.item\_type, self.name, self.persistent\_id, self.subtitle, self.icon\) class Factory: def \_\_init\_\_\(self, icon\_root\): self.dropped\_icon = os.path.join\(icon\_root, 'dropped@2x.png'\) self.flagged\_icon = os.path.join\(icon\_root, 'flagged@2x.png'\) self.on\_hold\_icon = os.path.join\(icon\_root, 'on-hold@2x.png'\) self.active\_icon = os.path.join\(icon\_root, 'active-small@2x.png'\) self.completed\_icon = os.path.join\(icon\_root, 'completed@2x.png'\) self.inbox\_icon = os.path.join\(icon\_root, 'inbox-sidebar@2x.png'\) self.perspective\_icon = os.path.join\(icon\_root, 'Perspectives@2x.png'\) self.deferred\_icon = os.path.join\('.', 'deferred.png'\) self.folder\_icon = os.path.join\(icon\_root, 'quickopen-folder@2x.png'\) self.setup\_perspective\_icons\(icon\_root\) self.icon\_lookup = dict\(zip\(DEFAULT\_OF3\_PERSPECTIVES, self.default\_perspective\_icons\)\) self.project\_icons = {STATUS\_ACTIVE: self.active\_icon, STATUS\_DONE: self.completed\_icon, STATUS\_DROPPED: self.dropped\_icon, STATUS\_INACTIVE: self.on\_hold\_icon} self.context\_icons = {1: self.active\_icon, 0: self.on\_hold\_icon} def setup\_perspective\_icons\(self, icon\_root\): self.context\_icon = os.path.join\(icon\_root, 'quickopen-tag@2x.png'\) self.inbox\_perspective\_icon = os.path.join\(icon\_root, 'AppIcon-Credits.png'\) self.projects\_perspective\_icon = os.path.join\(icon\_root, 'AppIcon-Credits.png'\) self.contexts\_perspective\_icon = os.path.join\(icon\_root, 'AppIcon-Credits.png'\) self.forecast\_perspective\_icon = os.path.join\(icon\_root, 'AppIcon-Credits.png'\) self.flagged\_perspective\_icon = os.path.join\(icon\_root, 'AppIcon-Credits.png'\) self.review\_perspective\_icon = os.path.join\(icon\_root, 'AppIcon-Credits.png'\) self.default\_perspective\_icons = \[self.inbox\_perspective\_icon, self.projects\_perspective\_icon, self.contexts\_perspective\_icon, self.forecast\_perspective\_icon, self.flagged\_perspective\_icon, self.review\_perspective\_icon\] def create\_project\(self, row\): pid = row\[ID\] name = row\[NAME\] status = row\[STATUS\] folder = row\[FOLDER\_NAME\] datetostart = deferred\_date\(row\[START\_DATE\], row\[EFFECTIVE\_START\_DATE\]\) icon = self.project\_icons\[status\] if status == 'active' and is\_deferred\(datetostart\): icon = self.deferred\_icon return Item\(item\_type='Project', persistent\_id=pid, name=name, icon=icon, subtitle=folder\) def create\_task\(self, row\): pid = row\[ID\] blocked\_by\_future\_date = row\[BLOCKED\_BY\_START\_DATE\] == 1 name = row\[NAME\] project = row\[PROJECT\_NAME\] inbox = \(row\[IN\_INBOX\] == 1 or row\[EFFECTIVE\_IN\_INBOX\] == 1\) datetostart = deferred\_date\(row\[START\_DATE\], row\[EFFECTIVE\_START\_DATE\]\) blocked = row\[BLOCKED\] == 1 children = row\[CHILD\_COUNT\] parent\_status = row\[STATUS\] icon = self.active\_icon if blocked\_by\_future\_date or \(blocked and not children\) or parent\_status != STATUS\_ACTIVE: icon = self.on\_hold\_icon if is\_deferred\(datetostart\): icon = self.deferred\_icon if inbox: icon = self.inbox\_icon if row\[DUE\_DATE\]: due\_date = parse\_datetime\(row\[DUE\_DATE\]\) if due\_date is not None: now = datetime.now\(\) due\_date\_label = due\_date.strftime\("%c"\) if now &gt; due\_date: name = name + " \(overdue: {0}\)".format\(due\_date\_label\) icon = ICON\_WARNING else: name = name + " \(due: {0}\)".format\(due\_date\_label\) else: name = name + " \(due date unknown\)" return Item\(item\_type='Task', persistent\_id=pid, name=name, icon=icon, subtitle=project\) def create\_context\(self, raw\_data\): pid = raw\_data\[ID\] name = raw\_data\[NAME\] allows\_next\_action = raw\_data\[ALLOWS\_NEXT\_ACTION\] available\_tasks = raw\_data\[AVAILABLE\_TASK\_COUNT\] if available\_tasks == 1: subtitle = "1 task available" else: subtitle = "{0} tasks available".format\(available\_tasks\) icon = self.context\_icons\[allows\_next\_action\] return Item\(item\_type='Context', persistent\_id=pid, name=name, icon=icon, subtitle=subtitle\) def create\_perspective\(self, name\): icon = self.perspective\_icon perspective\_type = 'Custom' if name in DEFAULT\_OF2\_PERSPECTIVES or name in DEFAULT\_OF3\_PERSPECTIVES: icon = self.icon\_lookup\[name\] perspective\_type = 'Default' return Item\(item\_type='Perspective', persistent\_id='', name=name, icon=icon, subtitle="Omnifocus {0} Perspective".format\(perspective\_type\)\) def create\_folder\(self, row\): pid = row\[ID\] name = row\[NAME\] return Item\(item\_type='Folder', persistent\_id=pid, name=name, icon=self.folder\_icon, subtitle=''\) def create\_recent\_item\(self, raw\_data\): task = self.create\_task\(raw\_data\) if raw\_data\[ID\] == raw\_data\[CONTAINING\_PROJECT\_INFO\]: task.name = task.name + " \(Project\)" else: task.name = task.name + " \(Task\)" mod\_date = raw\_data\[MODIFIED\_DATE\] try: modified\_date = datetime.fromtimestamp\(mod\_date + DATETIME\_OFFSET\).strftime\("%c"\) task.subtitle = modified\_date except: task.subtitle = "Unable to determine a modified date for this task {0}".format\(mod\_date\) return task def deferred\_date\(datetostart, effectivedatetostart\): if effectivedatetostart == 0: return datetostart def is\_deferred\(datetostart\): deferred = False if datetostart is not None: dts = parse\_datetime\(datetostart\) if dts &gt; datetime.now\(\): deferred = True return deferred def parse\_datetime\(value\): try: return datetime.strptime\(value, DATETIME\_FORMAT\) except: return None

